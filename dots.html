<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        .ascii-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.0;
            letter-spacing: 0;
            color: #00ff00;
            opacity: 0.8;
            white-space: pre;
            overflow: hidden;
            pointer-events: none;
            word-break: break-all;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .cross {
            position: absolute;
            width: 4vw;
            height: 4vw;
            min-width: 30px;
            min-height: 30px;
            max-width: 60px;
            max-height: 60px;
            background-color: #000000;
            border: 0.2vw solid #ff0000;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .cross.falling {
            transition: all 1s ease-in;
        }

        .arm-vertical,
        .arm-horizontal {
            position: fixed;
            background-color: #ff0000;
            z-index: 9;
            transition: all 0.3s ease;
        }

        .arm-vertical {
            width: 0.2vw;
            min-width: 1px;
            max-width: 3px;
            height: 100vh;
            top: 0;
        }

        .arm-horizontal {
            width: 100vw;
            height: 0.2vw;
            min-height: 1px;
            max-height: 3px;
            left: 0;
        }

        .coordinates {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-family: 'Smooth';
            font-size: 14px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #00ff00;
        }

        .target-box {
            position: absolute;
            width: 5vw;
            height: 5vw;
            min-width: 40px;
            min-height: 40px;
            max-width: 60px;
            max-height: 60px;
            background-color: #ff0000;
            /* border: 0.2vw solid #00ff00; */
            z-index: 5;
        }

        .color-reversed .cross {
            background-color: #000000;
        }

        .color-reversed .arm-vertical,
        .color-reversed .arm-horizontal {
            background-color: #000000;
        }

        .color-reversed .target-box {
            background-color: #ff0000;
            border-color: #000000;
        }

        .color-reversed body {
            background-color: #ff0000;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-family: 'smooth';
            font-size: 14px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #00ff00;
        }

        .coordinates {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-family: 'Galvji';
            font-size: 3vw;
            z-index: 0;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid #00ff00;
        }


        @font-face {
            font-family: "Smooth";
            src: url("font/smoothpet-1.ttf");
        }

        @font-face {
            font-family: "Oroban";
            src: url("font/AT Oroban Elegans.otf");
        }

        @font-face {
            font-family: "Galvji";
            src: url("font/Galvji.ttc");
        }
    </style>
</head>

<body>
    <div class="ascii-background" id="asciiBackground"></div>
    
    <div class="game-container">
        <div class="arm-vertical" id="armVertical"></div>
        <div class="arm-horizontal" id="armHorizontal"></div>
        <div class="cross" id="cross"></div>
        <div class="target-box" id="targetBox"></div>
    </div>

    <div class="coordinates">
        <div id="crossPos">Aim: (0,0)</div>
        <div id="targetPos">Target: (0,0)</div>
        <div id="distance">Distance: 0px</div>
    </div>

    <script>
        class DotsGame {
            constructor() {
                this.cross = document.getElementById('cross');
                this.targetBox = document.getElementById('targetBox');
                this.armVertical = document.getElementById('armVertical');
                this.armHorizontal = document.getElementById('armHorizontal');
                this.asciiBackground = document.getElementById('asciiBackground');
                this.crossPos = { x: 0, y: 0 };
                this.targetPos = { x: 0, y: 0 };
                this.moveInterval = null;
                this.isMoving = true;
                this.asciiInterval = null;
                this.imageList = [
                    'image/u4354911328_iphone_7_fake_news_shattered_screen_--chaos_10_--_5b719986-b3d8-4e50-9ea8-11995b29aab3_3.png'
                ];
                this.loadedImages = [];
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.initializePositions();
                this.loadImages().then(() => {
                    this.startAsciiAnimation();
                });
                this.startMovement();
                this.updateDisplay();
                this.addClickEvent();
            }

            initializePositions() {
                // Set initial positions
                const crossSize = this.getCrossSize();
                const targetSize = this.getTargetSize();

                this.crossPos = {
                    x: Math.random() * (window.innerWidth - crossSize),
                    y: Math.random() * (window.innerHeight - crossSize)
                };

                this.targetPos = {
                    x: Math.random() * (window.innerWidth - targetSize),
                    y: Math.random() * (window.innerHeight - targetSize)
                };

                this.updatePositions();
            }

            async loadImages() {
                const loadPromises = this.imageList.map(src => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => resolve(img);
                        img.onerror = () => {
                            console.warn(`Failed to load ${src}`);
                            resolve(null);
                        };
                        img.src = src;
                    });
                });

                const results = await Promise.all(loadPromises);
                this.loadedImages = results.filter(img => img !== null);
                console.log(`Loaded ${this.loadedImages.length} images`);
            }

            imageToAscii(img) {
                const cols = Math.floor(window.innerWidth / 7.5);
                const rows = Math.floor(window.innerHeight / 12);
                
                // Set canvas size to match ASCII grid
                this.canvas.width = cols;
                this.canvas.height = rows;
                
                // Draw scaled image to canvas
                this.ctx.drawImage(img, 0, 0, cols, rows);
                
                // Get pixel data
                const imageData = this.ctx.getImageData(0, 0, cols, rows);
                const pixels = imageData.data;
                
                // ASCII characters from darkest to brightest
                const asciiChars = ' .,:;-=+*#%@█▓▒░';
                let result = '';
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const offset = (i * cols + j) * 4;
                        const r = pixels[offset];
                        const g = pixels[offset + 1];
                        const b = pixels[offset + 2];
                        
                        // Calculate brightness (0-255)
                        const brightness = (r + g + b) / 3;
                        
                        // Map brightness to ASCII character
                        const charIndex = Math.floor((brightness / 255) * (asciiChars.length - 1));
                        result += asciiChars[charIndex];
                    }
                    result += '\n';
                }
                
                return result;
            }

            generateAsciiArt() {
                // If images are loaded, randomly pick one and convert to ASCII
                if (this.loadedImages.length > 0){
                // && Math.random() < 0.7) 
                    const randomImg = this.loadedImages[Math.floor(Math.random() * this.loadedImages.length)];
                    return this.imageToAscii(randomImg);
                }
                
                // Fallback: Different ASCII art patterns inspired by shattered phone screen
                const patterns = [
                    // Pattern 1: Shattered glass with radiating cracks
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        const centerX = cols / 2;
                        const centerY = rows / 2;
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const dx = j - centerX;
                                const dy = i - centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                // Create radiating crack pattern
                                if (dist < 3) {
                                    result += '✶✷✸✹✺✻✼✽✾✿❀❁❂❃❄❅❆❇'[Math.floor(Math.random() * 18)];
                                } else if (Math.abs(Math.sin(angle * 8 + dist * 0.5)) < 0.2) {
                                    result += '/\\|─═║╱╲╳'[Math.floor(Math.random() * 9)];
                                } else if (Math.random() < 0.1) {
                                    result += '※＊﹡٭*'[Math.floor(Math.random() * 5)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    },
                    // Pattern 2: Fragmented glass shards
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const noise = Math.sin(i * 0.5) * Math.cos(j * 0.3) + Math.random();
                                if (noise > 1.3) {
                                    result += '◆◇◈◊○◌◍◎●◐◑◒◓'[Math.floor(Math.random() * 13)];
                                } else if (noise > 0.9) {
                                    result += '▪▫▬▭▮▯'[Math.floor(Math.random() * 6)];
                                } else if (noise > 0.5) {
                                    result += '░▒▓'[Math.floor(Math.random() * 3)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    },
                    // Pattern 3: Spiderweb cracks
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        const centerX = cols / 2 + (Math.random() - 0.5) * 10;
                        const centerY = rows / 2 + (Math.random() - 0.5) * 10;
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const dx = j - centerX;
                                const dy = i - centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                // Spiderweb pattern
                                if (dist < 2) {
                                    result += '⊗⊕⊙⊛⊚⊜'[Math.floor(Math.random() * 6)];
                                } else if (Math.abs(Math.sin(angle * 6)) < 0.15 || Math.abs(dist % 5) < 0.3) {
                                    result += '─│┼┤├┬┴╋'[Math.floor(Math.random() * 8)];
                                } else if (Math.random() < 0.05) {
                                    result += '╱╲╳'[Math.floor(Math.random() * 3)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    },
                    // Pattern 4: Scattered glass fragments
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const cluster = Math.sin(i * 0.7 + j * 0.5) * Math.cos(i * 0.3 - j * 0.4);
                                if (cluster > 0.7) {
                                    result += '◢◣◤◥'[Math.floor(Math.random() * 4)];
                                } else if (cluster > 0.4) {
                                    result += '▲△▼▽◀◁▶▷'[Math.floor(Math.random() * 8)];
                                } else if (Math.random() < 0.08) {
                                    result += '⋄⋅∘∙'[Math.floor(Math.random() * 4)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    },
                    // Pattern 5: Impact point with radiating lines
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        const impactX = Math.floor(cols / 2 + (Math.random() - 0.5) * 20);
                        const impactY = Math.floor(rows / 2 + (Math.random() - 0.5) * 10);
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const dx = j - impactX;
                                const dy = i - impactY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                if (dist < 1.5) {
                                    result += '★☆✦✧✨✩✪✫✬✭✮✯✰'[Math.floor(Math.random() * 13)];
                                } else if (Math.abs(Math.sin(angle * 12)) < 0.12) {
                                    result += '═║╔╗╚╝╠╣╦╩╬'[Math.floor(Math.random() * 11)];
                                } else if (Math.abs(Math.cos(angle * 16)) < 0.1) {
                                    result += '━│┏┓┗┛┣┫┳┻╋'[Math.floor(Math.random() * 11)];
                                } else if (Math.random() < 0.03) {
                                    result += '▪▫'[Math.floor(Math.random() * 2)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    },
                    // Pattern 6: Broken screen texture
                    () => {
                        const cols = Math.floor(window.innerWidth / 7.5);
                        const rows = Math.floor(window.innerHeight / 12);
                        let result = '';
                        
                        for (let i = 0; i < rows; i++) {
                            for (let j = 0; j < cols; j++) {
                                const pattern = (i + j) % 7;
                                const intensity = Math.random();
                                
                                if (pattern === 0 && intensity > 0.5) {
                                    result += '▓▒░'[Math.floor(Math.random() * 3)];
                                } else if (pattern === 1 && intensity > 0.6) {
                                    result += '▀▄█'[Math.floor(Math.random() * 3)];
                                } else if (pattern === 2 && intensity > 0.7) {
                                    result += '■□▪▫'[Math.floor(Math.random() * 4)];
                                } else if (intensity > 0.9) {
                                    result += '※*'[Math.floor(Math.random() * 2)];
                                } else {
                                    result += ' ';
                                }
                            }
                            result += '\n';
                        }
                        return result;
                    }
                ];

                // Pick a random pattern
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                return pattern();
            }

            startAsciiAnimation() {
                // Update ASCII art at random intervals
                const updateAscii = () => {
                    // Add fade out effect
                    this.asciiBackground.style.transition = 'opacity 0.3s ease-out';
                    this.asciiBackground.style.opacity = '0';
                    
                    setTimeout(() => {
                        this.asciiBackground.textContent = this.generateAsciiArt();
                        // Fade back in
                        this.asciiBackground.style.opacity = '0.8';
                    }, 300);
                    
                    const nextInterval = Math.random() * 4000 + 2000; // 2-6 seconds
                    this.asciiInterval = setTimeout(updateAscii, nextInterval);
                };
                
                updateAscii();
            }

            stopAsciiAnimation() {
                if (this.asciiInterval) {
                    clearTimeout(this.asciiInterval);
                    this.asciiInterval = null;
                }
            }

            getTargetSize() {
                // Get the actual computed size of the target
                const targetRect = this.targetBox.getBoundingClientRect();
                return targetRect.width;
            }

            updatePositions() {
                this.cross.style.left = this.crossPos.x + 'px';
                this.cross.style.top = this.crossPos.y + 'px';

                // Position the arms to intersect at the cross center
                const crossSize = this.getCrossSize();
                const crossCenterX = this.crossPos.x + (crossSize / 2);
                const crossCenterY = this.crossPos.y + (crossSize / 2);

                this.armVertical.style.left = crossCenterX + 'px';
                this.armHorizontal.style.top = crossCenterY + 'px';

                this.targetBox.style.left = this.targetPos.x + 'px';
                this.targetBox.style.top = this.targetPos.y + 'px';
            }

            getCrossSize() {
                // Get the actual computed size of the cross
                const crossRect = this.cross.getBoundingClientRect();
                return crossRect.width;
            }

            updateDisplay() {
                document.getElementById('crossPos').textContent =
                    `Cross: (${Math.round(this.crossPos.x)},${Math.round(this.crossPos.y)})`;
                document.getElementById('targetPos').textContent =
                    `Target: (${Math.round(this.targetPos.x)},${Math.round(this.targetPos.y)})`;

                const distance = Math.sqrt(
                    Math.pow(this.crossPos.x - this.targetPos.x, 2) +
                    Math.pow(this.crossPos.y - this.targetPos.y, 2)
                );
                document.getElementById('distance').textContent =
                    `Distance: ${Math.round(distance)}px`;
            }

            getRandomMove() {
                const moves = [];
                const stepSize = Math.max(30, window.innerWidth * 0.05); // Responsive step size
                const crossSize = this.getCrossSize();

                // Generate possible moves
                const directions = [
                    { x: stepSize, y: 0 },    // right
                    { x: -stepSize, y: 0 },   // left
                    { x: 0, y: stepSize },    // down
                    { x: 0, y: -stepSize },   // up
                    { x: stepSize, y: stepSize },   // diagonal down-right
                    { x: -stepSize, y: stepSize },  // diagonal down-left
                    { x: stepSize, y: -stepSize },  // diagonal up-right
                    { x: -stepSize, y: -stepSize } // diagonal up-left
                ];

                directions.forEach(dir => {
                    const newX = this.crossPos.x + dir.x;
                    const newY = this.crossPos.y + dir.y;

                    // Check if move is within bounds
                    if (newX >= 0 && newX <= window.innerWidth - crossSize &&
                        newY >= 0 && newY <= window.innerHeight - crossSize) {

                        // Calculate distance to target after this move
                        const distanceAfterMove = Math.sqrt(
                            Math.pow(newX - this.targetPos.x, 2) +
                            Math.pow(newY - this.targetPos.y, 2)
                        );

                        // Calculate current distance
                        const currentDistance = Math.sqrt(
                            Math.pow(this.crossPos.x - this.targetPos.x, 2) +
                            Math.pow(this.crossPos.y - this.targetPos.y, 2)
                        );

                        // Prefer moves that maintain or increase distance from target
                        if (distanceAfterMove >= currentDistance - 20) {
                            moves.push({ x: newX, y: newY });
                        }
                    }
                });

                // If no good moves, just pick any valid move
                if (moves.length === 0) {
                    directions.forEach(dir => {
                        const newX = this.crossPos.x + dir.x;
                        const newY = this.crossPos.y + dir.y;

                        if (newX >= 0 && newX <= window.innerWidth - 40 &&
                            newY >= 0 && newY <= window.innerHeight - 40) {
                            moves.push({ x: newX, y: newY });
                        }
                    });
                }

                return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
            }

            moveCross() {
                const move = this.getRandomMove();

                if (move) {
                    this.crossPos = move;
                    this.updatePositions();
                    this.updateDisplay();
                }
            }

            startMovement() {
                const move = () => {
                    this.moveCross();
                    const nextInterval = Math.random() * 3000 + 1500; // 1.5-4.5 seconds
                    this.moveInterval = setTimeout(move, nextInterval);
                };

                move();
            }

            stopMovement() {
                if (this.moveInterval) {
                    clearTimeout(this.moveInterval);
                    this.moveInterval = null;
                }
            }

            addClickEvent() {
                document.addEventListener('click', (event) => {
                    if (!this.isMoving) return; // Only allow clicks during movement
                    this.triggerFall();
                });
            }

            triggerFall() {
                // Stop movement and ASCII animation
                this.stopMovement();
                this.stopAsciiAnimation();
                this.isMoving = false;

                // Add falling class for slower transition
                this.cross.classList.add('falling');

                // Move cross to target center
                const targetSize = this.getTargetSize();
                const crossSize = this.getCrossSize();

                this.crossPos = {
                    x: this.targetPos.x + (targetSize - crossSize) / 2,
                    y: this.targetPos.y + (targetSize - crossSize) / 2
                };

                this.updatePositions();

                // Reverse colors and show image after a short delay
                setTimeout(() => {
                    // Hide ASCII background
                    this.asciiBackground.style.opacity = '0';
                    
                    // Show image
                    document.body.style.backgroundColor = "black";
                    document.body.style.backgroundImage = "url('image/u4354911328_iphone_7_fake_news_shattered_screen_--chaos_10_--_5b719986-b3d8-4e50-9ea8-11995b29aab3_3.png')";
                    document.body.style.backgroundSize = "cover";
                    document.body.style.backgroundPosition = "center";
                    document.body.style.backgroundRepeat = "no-repeat";
                }, 500);

                // Restart game after 5 seconds
                setTimeout(() => {
                    this.restartGame();
                }, 5000);
            }

            restartGame() {
                // Remove image background
                document.body.style.backgroundColor = "black";
                document.body.style.backgroundImage = "none";

                // Show ASCII background again
                this.asciiBackground.style.opacity = '0.8';

                // Remove falling class
                this.cross.classList.remove('falling');

                // Reset movement flag
                this.isMoving = true;

                // Reset positions
                this.initializePositions();

                // Restart ASCII animation
                this.startAsciiAnimation();

                // Restart movement
                this.startMovement();
            }
        }

        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DotsGame();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            // Keep cross and target within bounds
            if (window.game) {
                const crossSize = window.game.getCrossSize();
                const targetSize = window.game.getTargetSize();

                window.game.crossPos.x = Math.min(window.game.crossPos.x, window.innerWidth - crossSize);
                window.game.crossPos.y = Math.min(window.game.crossPos.y, window.innerHeight - crossSize);

                window.game.targetPos.x = Math.min(window.game.targetPos.x, window.innerWidth - targetSize);
                window.game.targetPos.y = Math.min(window.game.targetPos.y, window.innerHeight - targetSize);

                window.game.updatePositions();
                
                // Refresh ASCII art for new screen size
                if (window.game.isMoving) {
                    window.game.asciiBackground.textContent = window.game.generateAsciiArt();
                }
            }
        });
    </script>
</body>

</html>