<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Break</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            background-color: #fff;
        }

        .message {
            position: absolute;
            color: #ff0000;
            font-family: "Oroban";
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            white-space: nowrap;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border: 1px solid #ff0000;
            border-radius: 3px;
        }

        @font-face {
            font-family: "Smooth";
            src: url("font/smoothpet-1.ttf");
        }

        @font-face {
            font-family: "Oroban";
            src: url("font/AT Oroban Elegans.otf");
        }

        @font-face {
            font-family: "Galvji";
            src: url("font/Galvji.ttc");
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        class Ball {
            constructor(x, y, radius, color, isRed = false, index = 0) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.baseColor = color;
                this.isRed = isRed;
                this.index = index;
                this.vx = 0;
                this.vy = 0;
                this.connected = true;
                this.gravity = 0.5;
                this.friction = 0.99;
                this.baseX = x;
                this.baseY = y;
                // Each ball has unique phase offsets for organic movement
                this.phaseX = Math.random() * Math.PI * 2;
                this.phaseY = Math.random() * Math.PI * 2;
                this.speedX = 0.8 + Math.random() * 0.4; // Random speed multiplier
                this.speedY = 0.8 + Math.random() * 0.4;
                this.amplitudeX = 40 + Math.random() * 30; // Random amplitude
                this.amplitudeY = 15 + Math.random() * 15;
                // Animation properties
                this.animatingUp = false;
                this.animationProgress = 0;
                this.targetY = y;
                this.startY = y;
                // Trail properties
                this.trail = []; // Array of {x, y, color, timestamp}
                this.maxTrailLength = 500; // Maximum trail points
            }

            updateTrail() {
                // Add current position to trail
                this.trail.push({
                    x: this.x,
                    y: this.y,
                    color: this.color,
                    timestamp: Date.now()
                });

                // Remove old trail points and those older than 5 seconds
                const now = Date.now();
                this.trail = this.trail.filter(point => {
                    return now - point.timestamp < 5000; // Keep for 5 seconds
                });

                // Also limit trail length
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }

            drawTrail(ctx) {
                const now = Date.now();

                // Draw trail points from oldest to newest
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const age = now - point.timestamp;
                    const maxAge = 1000; // 5 seconds

                    // Calculate opacity with smooth fade (1 to 0)
                    const normalizedAge = Math.min(age / maxAge, 1);

                    // Simple linear fade for full range 0-1
                    const opacity = Math.max(0, 1 - normalizedAge);
                    console.log(opacity);
                    console.log(age);

                    // Skip if completely transparent
                    if (opacity <= 0) continue;

                    // Calculate size based on position in trail (smaller towards the back)
                    const sizeMultiplier = 1 + (i / this.trail.length) * 0;
                    const pointRadius = this.radius * sizeMultiplier;

                    // Parse color and add opacity
                    let r, g, b;
                    if (point.color === '#00ff00') {
                        r = 0; g = 255; b = 0;
                    } else {
                        r = 0; g = 0; b = 0;
                    }

                    ctx.beginPath();
                    ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    ctx.fill();
                }
            }

            draw(ctx) {
                // Draw trail first (behind the ball)
                this.drawTrail(ctx);

                // Draw flat ball without gradient
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                // No stroke/outline
                ctx.closePath();

                // Draw tag above the ball
                const tagText = this.color === '#00ff00' ? 'ON' : 'OFF';
                const tagY = this.y - this.radius - 8;

                // Set font properties
                ctx.font = '12px Arial';
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // Draw the tag
                ctx.fillText(tagText, this.x, tagY);
            }

            update(canvas) {
                if (!this.connected) {
                    // Apply gravity
                    this.vy += this.gravity;
                    this.vx *= this.friction;
                    this.vy *= this.friction;

                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                } else if (this.animatingUp) {
                    // Animate ball coming up from below
                    this.animationProgress += 0.05;
                    if (this.animationProgress >= 1) {
                        this.animationProgress = 1;
                        this.animatingUp = false;
                    }

                    // Ease-out-back for bounce effect
                    const t = this.animationProgress;
                    const c1 = 1.70158;
                    const c3 = c1 + 1;
                    const eased = 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);

                    this.baseY = this.startY + (this.targetY - this.startY) * eased;
                }
            }

            startAnimateUp(targetY, delay = 0) {
                setTimeout(() => {
                    this.startY = window.innerHeight + 100; // Start below screen
                    this.baseY = this.startY;
                    this.targetY = targetY;
                    this.animatingUp = true;
                    this.animationProgress = 0;
                    this.connected = true;
                }, delay);
            }

            isOffScreen(canvas) {
                return this.y - this.radius > canvas.height;
            }
        }

        class Chain {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.balls = [];
                this.numBalls = 10; // More balls for longer chain
                this.ballRadius = 12;
                this.chainWidth = this.canvas.width * 0.7; // 70vw
                this.spacing = this.chainWidth / (this.numBalls - 1); // Dynamic spacing
                this.redBallIndex = -1;
                this.broken = false;
                this.messageElement = null;
                this.time = 0;
                this.colorChangeIntervals = [];
                this.currentRedBalls = new Set(); // Track which balls are currently red

                this.init();
                this.startColorChanges();
            }

            init() {
                // Create chain of balls horizontally spanning 70vw
                const startX = this.canvas.width * 0.15; // 15vw margin on left (centered)
                const startY = this.canvas.height / 2;

                for (let i = 0; i < this.numBalls; i++) {
                    const x = startX + i * this.spacing;
                    const y = startY;
                    const ball = new Ball(x, y, this.ballRadius, '#000000', false, i);
                    this.balls.push(ball);
                }

                // Choose random ball to start as green (not first or last 2)
                this.redBallIndex = Math.floor(Math.random() * (this.numBalls - 4)) + 2;
                this.balls[this.redBallIndex].color = '#00ff00'; // Neon green
                this.balls[this.redBallIndex].isRed = true; // Just a flag (historically named)

                // // Create message element
                // this.createMessage();
            }

            // createMessage() {
            //     this.messageElement = document.createElement('div');
            //     this.messageElement.className = 'message';
            //     this.messageElement.textContent = 'break me off';
            //     document.body.appendChild(this.messageElement);
            //     this.updateMessagePosition();
            // }

            updateMessagePosition() {
                if (this.messageElement && !this.broken && this.redBallIndex >= 0) {
                    const redBall = this.balls[this.redBallIndex];
                    this.messageElement.style.left = (redBall.x - 50) + 'px';
                    this.messageElement.style.top = (redBall.y - redBall.radius - 40) + 'px';
                }
            }

            startColorChanges() {
                // Stop any existing intervals
                this.stopColorChanges();

                // Schedule random color changes for each ball
                this.balls.forEach((ball, index) => {
                    const scheduleChange = () => {
                        const delay = Math.random() * 7000 + 5000; // 5-12 seconds
                        const timeout = setTimeout(() => {
                            if (!this.broken && ball.connected) {
                                // Make sure not all balls are green
                                if (!this.wouldAllBeGreen(index)) {
                                    ball.color = '#00ff00'; // Neon green
                                    this.currentRedBalls.add(index); // Keep same tracking (just means "changed color")

                                    // Change back to black after some time
                                    setTimeout(() => {
                                        if (!this.broken) {
                                            ball.color = ball.baseColor; // Back to black
                                            this.currentRedBalls.delete(index);
                                        }
                                    }, Math.random() * 3000 + 1000);
                                }
                            }
                            scheduleChange(); // Schedule next change
                        }, delay);
                        this.colorChangeIntervals.push(timeout);
                    };
                    scheduleChange();
                });
            }

            wouldAllBeGreen(newGreenIndex) {
                // Check if adding this ball as green would make all balls green
                const potentialGreenCount = this.currentRedBalls.size + 1;
                return potentialGreenCount >= this.numBalls;
            }

            stopColorChanges() {
                this.colorChangeIntervals.forEach(timeout => clearTimeout(timeout));
                this.colorChangeIntervals = [];
            }

            breakChain() {
                if (this.broken) return;

                this.broken = true;

                // Stop color changes
                this.stopColorChanges();

                // Hide message
                if (this.messageElement) {
                    this.messageElement.style.display = 'none';
                }

                // Turn ALL balls neon green and disconnect them
                this.balls.forEach(ball => {
                    ball.color = '#00ff00'; // Neon green
                    ball.connected = false;
                    // Add some random velocity for falling effect
                    ball.vx = (Math.random() - 0.5) * 1;
                    ball.vy = Math.random() * 1;
                });
            }

            draw() {
                // Draw connections with variable thickness
                for (let i = 0; i < this.balls.length - 1; i++) {
                    if (this.balls[i].connected && this.balls[i + 1].connected) {
                        const ball1 = this.balls[i];
                        const ball2 = this.balls[i + 1];

                        // Calculate control point for bezier curve
                        const midX = (ball1.x + ball2.x) / 2;
                        const midY = (ball1.y + ball2.y) / 2;
                        const offsetY = (ball2.y - ball1.y) * 0.2;

                        // Determine color
                        let color1 = ball1.color;
                        let color2 = ball2.color;

                        // Draw connection as a tapered shape (thick at ends, thin in middle)
                        const segments = 20; // Number of segments for smooth tapering

                        for (let s = 0; s < segments; s++) {
                            const t1 = s / segments;
                            const t2 = (s + 1) / segments;

                            // Calculate positions along the curve
                            const p1 = this.getQuadraticPoint(ball1.x, ball1.y, midX, midY + offsetY, ball2.x, ball2.y, t1);
                            const p2 = this.getQuadraticPoint(ball1.x, ball1.y, midX, midY + offsetY, ball2.x, ball2.y, t2);

                            // Calculate thickness - thick at ends, thin in middle
                            // Invert sine wave: thick at ends (8px), thin in middle (1px)
                            const thickness1 = 30 - Math.abs(Math.sin(t1 * Math.PI)) * 25;
                            const thickness2 = 30 - Math.abs(Math.sin(t2 * Math.PI)) * 25;

                            // Interpolate color
                            const segmentColor = this.interpolateColor(color1, color2, (t1 + t2) / 2);

                            // Draw segment
                            this.ctx.strokeStyle = segmentColor;
                            this.ctx.lineWidth = (thickness1 + thickness2) / 2;
                            this.ctx.lineCap = 'round';
                            this.ctx.lineJoin = 'round';

                            this.ctx.beginPath();
                            this.ctx.moveTo(p1.x, p1.y);
                            this.ctx.lineTo(p2.x, p2.y);
                            this.ctx.stroke();
                        }
                    }
                }

                // Draw balls
                this.balls.forEach(ball => ball.draw(this.ctx));
            }

            getQuadraticPoint(x1, y1, cx, cy, x2, y2, t) {
                // Calculate point on quadratic bezier curve at parameter t (0 to 1)
                const mt = 1 - t;
                return {
                    x: mt * mt * x1 + 2 * mt * t * cx + t * t * x2,
                    y: mt * mt * y1 + 2 * mt * t * cy + t * t * y2
                };
            }

            interpolateColor(color1, color2, t) {
                // Simple color interpolation
                if (color1 === color2) return color1;

                // Parse hex colors
                const c1 = parseInt(color1.slice(1), 16);
                const c2 = parseInt(color2.slice(1), 16);

                const r1 = (c1 >> 16) & 0xff;
                const g1 = (c1 >> 8) & 0xff;
                const b1 = c1 & 0xff;

                const r2 = (c2 >> 16) & 0xff;
                const g2 = (c2 >> 8) & 0xff;
                const b2 = c2 & 0xff;

                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);

                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }

            update() {
                // Update trails for all balls
                this.balls.forEach(ball => ball.updateTrail());

                // More organic floating animation for connected balls - HORIZONTAL
                if (!this.broken) {
                    this.time += 0.03; // Increased speed for more movement

                    this.balls.forEach((ball, index) => {
                        if (ball.connected) {
                            // Multiple sine waves combined for organic movement
                            const startX = this.canvas.width * 0.15; // Same as init
                            const baseX = startX + index * this.spacing;
                            const baseY = this.canvas.height / 2;

                            // Check if this is the red ball - give it STRANGE movement
                            // if (index === this.redBallIndex) {
                            //     // Chaotic, erratic movement for red ball
                            //     const chaosX1 = Math.sin(this.time * 3.5 + ball.phaseX) * ball.amplitudeX * 1.2;
                            //     const chaosX2 = Math.cos(this.time * 5.2 - ball.phaseX) * ball.amplitudeX * 0.8;
                            //     const chaosX3 = Math.sin(this.time * 7.3) * 30;

                            //     const chaosY1 = Math.cos(this.time * 4.1 + ball.phaseY) * ball.amplitudeY * 1.8;
                            //     const chaosY2 = Math.sin(this.time * 6.7 - ball.phaseY) * ball.amplitudeY * 1.2;
                            //     const chaosY3 = Math.cos(this.time * 8.9) * 40;
                            //     const chaosY4 = Math.sin(this.time * 2.3) * Math.cos(this.time * 3.7) * 25;

                            //     // Add jittery, glitchy effect
                            //     const jitterX = (Math.random() - 0.5) * 5;
                            //     const jitterY = (Math.random() - 0.5) * 5;

                            //     // Circular motion component
                            //     const circleRadius = 10 + Math.sin(this.time * 2) * 10;
                            //     const circleX = Math.cos(this.time * 4) * circleRadius;
                            //     const circleY = Math.sin(this.time * 4) * circleRadius;

                            //     ball.x = baseX + chaosX1 + chaosX2 + chaosX3 + circleX + jitterX;
                            //     ball.y = baseY + chaosY1 + chaosY2 + chaosY3 + chaosY4 + circleY + jitterY;
                            // } else {
                            // Normal movement for other balls
                            const wave1X = Math.sin(this.time * ball.speedX + ball.phaseX + index * 0.4) * (ball.amplitudeX * 0.3);
                            const wave1Y = Math.cos(this.time * ball.speedY + ball.phaseY + index * 0.3) * ball.amplitudeY;

                            const wave2X = Math.sin(this.time * 0.7 + index * 0.6) * (ball.amplitudeX * 0.15);
                            const wave2Y = Math.cos(this.time * 0.5 + index * 0.4) * (ball.amplitudeY * 0.5);

                            const pendulumFactor = Math.pow(index / this.numBalls, 1.5);

                            ball.x = baseX + (wave1X + wave2X) * (0.3 + pendulumFactor * 0.5);
                            ball.y = baseY + (wave1Y + wave2Y) * (0.5 + pendulumFactor);
                            // }
                        }
                    });
                }

                // Update physics for disconnected balls
                this.balls.forEach(ball => ball.update(this.canvas));

                // Remove balls that are off screen
                this.balls = this.balls.filter(ball => !ball.isOffScreen(this.canvas));

                // Update message position
                this.updateMessagePosition();
            }

            reset() {
                // Remove old message
                if (this.messageElement) {
                    this.messageElement.remove();
                }

                // Reset state
                this.balls = [];
                this.broken = false;
                this.time = 0;
                this.currentRedBalls.clear();

                // Reinitialize
                this.init();

                // Animate balls coming up with staggered delays
                const startX = this.canvas.width * 0.15;
                const targetY = this.canvas.height / 2;
                this.balls.forEach((ball, index) => {
                    const delay = index * 50; // 50ms stagger
                    ball.startAnimateUp(targetY, delay);
                });

                // Restart color changes after animation completes
                setTimeout(() => {
                    this.startColorChanges();
                }, this.numBalls * 50 + 1000);
            }
        }

        class ChainGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.chain = null;
                this.animationId = null;
                this.showWinMessage = false;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.chain = new Chain(this.canvas);

                this.canvas.addEventListener('click', () => this.handleClick());

                this.animate();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Recalculate chain dimensions on resize
                if (this.chain) {
                    this.chain.chainWidth = this.canvas.width * 0.7;
                    this.chain.spacing = this.chain.chainWidth / (this.chain.numBalls - 1);
                }
            }

            handleClick() {
                if (this.chain && !this.chain.broken) {
                    this.chain.breakChain();

                    // Reset after 5 seconds (balls should be off screen by then)
                    setTimeout(() => {
                        this.chain.reset();
                        this.showWinMessage = false; // Hide win message when balls come back up
                    }, 5000);
                }
            }

            animate() {
                // Clear canvas with appropriate background
                if (this.showWinMessage) {
                    // Create gradient background for win message
                    const gradient = this.ctx.createLinearGradient(this.canvas.width / 2, this.canvas.height, this.canvas.width/2,  this.canvas.height * 1/2);
                    gradient.addColorStop(0, '#000000'); // Black at top-left
                    gradient.addColorStop(0.2, '#00ff00'); // Green in middle
                    gradient.addColorStop(1, '#ffffff'); // White at bottom-right

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // White background for normal gameplay
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                // Update and draw
                if (this.chain) {
                    this.chain.update();
                    this.chain.draw();

                    // Check if all balls are off screen and show win message
                    if (this.chain.broken && !this.showWinMessage) {
                        const allOffScreen = this.chain.balls.every(ball =>
                            ball.y > this.canvas.height + ball.radius
                        );

                        if (allOffScreen) {
                            this.showWinMessage = true;
                        }
                    }
                }

                // Draw win message if shown
                if (this.showWinMessage) {
                    this.ctx.font = '48px Arial';
                    this.ctx.fillStyle = '#000000';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('You won?', this.canvas.width / 2, this.canvas.height / 2);
                }

                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        // Start the game
        window.addEventListener('DOMContentLoaded', () => {
            new ChainGame();
        });
    </script>
</body>

</html>